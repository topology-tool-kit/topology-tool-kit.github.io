<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Topology ToolKit">
    <meta name="author" content="The Topology ToolKit">
    <meta name="keywords" content="TTK, Topology ToolKit, Topological Data 
Analysis, Visualization, Reeb graph, Reeb Space, Morse-Smale complex, contour 
tree, persistence diagram, persistence curve, continuous scatterplot, fiber 
surface, contour forests, jacobi set, mandatory critical points, topological 
simplification, VTK, ParaView, Python" />

    <title>TTK - the Topology ToolKit</title>

    <!-- Bootstrap Core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Theme CSS -->
    <link href="css/clean-blog.min.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga'
);

  ga('create', 'UA-88087813-1', 'auto');
  ga('send', 'pageview');

</script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  var pluginUrl =
  '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-88087813-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type =
      'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl'
      : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- End Google Analytics -->
 <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { 
equationNumbers: { autoNumber: "all" } } }); </script>
       <script type="text/x-mathjax-config">
         MathJax.Hub.Config({
           tex2jax: {
             inlineMath: [ ['$','$'], ["\\(","\\)"] ],
             processEscapes: true
           }
         });
       </script>
       <script 
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-
MML_HTMLorMML" type="text/javascript"></script>
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" 
data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    Menu <i class="fa fa-bars"></i>
                </button>
                <a class="navbar-brand" href="index.html">
                TTK Home</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling 
-->
            <div class="collapse navbar-collapse" 
id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="gallery.html">Gallery</a>
                    </li>
                    <li>
                        <a href="downloads.html">Downloads</a>
                    </li>
                    <li>
                        <a href="installation.html">Installation</a>
                    </li>
                    <li>
                        <a href="tutorials.html">Tutorials</a>
                    </li>
                    <li>
                        <a href="documentation.html">Documentation</a>
                    </li>
                    <li>
                        <a href="contribute.html">Contribute</a>
                    </li>
                    <li>
                        <a href="contact.html">Contact</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header class="intro-header" 
      style="background-image: url('img/builtinExample.png'">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="page-heading">
                        <h1>Topology ToolKit</h1>
                        <hr class="small">
                        <span class="subheading">Tutorials</span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

<p>
<h3>
Persistent Homology for Dummies</h3>
<br>

The purpose of this exercise tutorial is threefold:<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; Introduce you to the usage of TTK in 
ParaView and Python;<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; Introduce you to persistent homology from a 
practical point of view;<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; Introduce you to the applications of 
persistent homology to medical data segmentation.
<br><br>

This exercise requires some very mild background in Python. <br>
It should take no more than 2 hours of your time.

<br><br>

<p>
<h4><a name="betti_downloads">1.</a> Downloads</h4>
In the following, we will assume that TTK has been installed successfully on 
your system. If not, please visit our installation page for detailed 
instructions
<a href="installation.html" target="new">
HERE</a>.<br>

Before starting the exercise, please download the data package 
<a href="https://codeload.github.com/topology-tool-kit/ttk-data/tar.gz/v0.9.3" 
target=new>
HERE</a>.<br>

Move the tarball to a working directory (for instance called 
<code>~/ttk</code>) and decompress it by entering the following commands (omit 
the <code>$</code> character)  in 
a terminal (this assumes that you downloaded the tarball to the 
<code>~/Downloads</code> directory):<br><br>
<code>$ mkdir ~/ttk</code><br>
<code>$ mv ~/Downloads/ttk-data-0.9.3.tar.gz ~/ttk/</code><br>
<code>$ cd ~/ttk</code><br>
<code>$ tar xvzf ttk-data-0.9.3.tar.gz</code><br><br>
You can delete the tarball after decompression by
entering the following command:<br><br>
<code>$ rm ttk-data-0.9.3.tar.gz</code><br>


</p>


<p>
<h4><a name="betti_paraview">2.</a> TTK/ParaView 101</h4>

<a href="http://www.paraview.org" target="new">ParaView</a> is the leading 
application for the interactive analysis and visualization of scientific data. 
It is open-source (BSD license). It is developed by <a 
href="http://www.kitware.com" target="new">Kitware</a>, a prominent company in 
open-source software (<a href="http://www.cmake.org" target="new">CMake</a>,
<a href="http://www.cdash.org" target="new">CDash</a>,
<a href="http://www.vtk.org" target="new">VTK</a>,
<a href="http://www.itk.org" target="new">ITK</a>, etc.).<br><br>
 
ParaView is a graphical user interface to the <a href="http://www.vtk.org" 
target="new">Visualization ToolKit</a>, a C++ library for data 
visualization and analysis, also developed in open-source by Kitware.<br>



<div class=caption>
  <a href="img/bettiNumbers_intro.png" target="new">
    <img width="100%" src="img/bettiNumbers_intro.png">
  </a>
</div>

VTK and ParaView both implement a 
pipeline model, where the data to analyze and visualize is passed on the input 
of a (possibly complex) sequence of elementary processing units, called 
<i>filters</i>. Each filter is implemented by a single C++ class in VTK. In 
ParaView, users can design advanced processing pipelines
by placing manually each filter in their
pipelines. <br>
In the above example, the active pipeline (shown in the "Pipeline Browser", 
upper left panel) can be interpreted as a series of processing instructions and 
reads similarly to some source code:
first, the input PL 3-manifold is clipped (<code>Clip1</code>); second, the 
boundary of the input PL 3-manifold is extracted 
(<code>ExtractSurface1</code>), third the connected components of the boundary 
are isolated and clipped with the same parameters as the rest of the volume 
(<code>Clip2</code>).<br><br>
 
The output of each filter can be visualized independently (by 
toggling the eye icon, left column). The algorithmic parameters of each filter 
can be tuned in the "Properties" panel (bottom left panel)  by selecting a 
filter in the pipeline (in the above example 
<code>GenerateSurfaceNormals1</code>).  
The display properties of the output of a filter in the main central view can 
also be modified from this panel.<br>

<div class=caption>
  <a href="img/bettiNumbers_menu.png" target="new">
    <img width="100%" src="img/bettiNumbers_menu.png">
  </a>
</div>
To create a pipeline from scratch, users typically load their input data and 
apply successively the required filters, by browsing the filter menu 
(exhaustive list shown above), where the filters which are not compatible 
with the object currently selected in the pipeline are shaded. <br>

<div class=caption>
  <a href="img/bettiNumbers_search.png" target="new">
    <img width="100%" src="img/bettiNumbers_search.png">
  </a>
</div>
Alternatively to the filter menu, users can toggle a fast search dialog by 
pressing the <code>Ctrl+space</code> keystroke (under Linux) and enter keywords 
as shown above to quickly call filters.<br><br>

ParaView supports the rendering of multiple (possibly linked) views. To 
generate a new view, users simply need to click on the vertical or horizontal 
split buttons, located at the top right of the current render view. To 
link two views together (i.e. to synchronize them in terms of view 
point), users simply need to right-click in one of the two views, then 
select the <code>Link Camera...</code> entry and finally click in the 
other view they wish to link.<br><br>

Once users are satisfied with their analysis and visualization pipeline, they 
can save it to disk for later re-use in the form of a Python script with the 
menu <code>File</code>, <code>Save state...</code> and choosing the Python 
state file type. In the Python script, each filter instance is modeled by an 
independent Python object, for which attributes can be changed and functions 
can be called.<br>
Note that the output Python script can be run independently of ParaView (for 
instance in batch mode) and its content can be included in any Python code (the 
<code>pvpython</code> interpreter is then recommended). Thus, ParaView can be 
viewed as an interactive designer of advanced analysis Python programs. 
To 
learn more about the available ParaView filters, please see the following 
tutorials:
<a href="http://www-pequan.lip6.fr/~tierny/visualizationExerciseParaView.html"
target="new">
HERE </a>
and 
<a href="http://www.paraview.org/Wiki/The_ParaView_Tutorial"
target="new">
THERE</a>.
<br><br>

In the following, it is highly recommended to regularly save the current status 
of your analysis, by saving a <code>.pvsm</code> state file with the menu 
<code>File</code>, <code>Save state...</code> (ideally, on file per exercise).

</p>

<p>
<h4><a name="betti_paraview">3.</a> Generating some toy data</h4>

<h4>Exercise 1</h4>
In the first part of this tutorial, we will experiment with some toy 2D data 
that we will synthesize ourselves. Open ParaView and simply call the 
<code>Plane</code> filter (also available in the <code>Sources</code> menu). 
Create a new plane with sufficient values for the 
parameters <code>XResolution</code>  and <code>YResolution</code> (typically 
100 each).<br><br>

ParaView supports real-time interfacing with the Python scripting language. 
For instance, by calling the <code>Programmable Source</code> or the 
<code>Programmable Filter</code>, users can directly type in Python commands to 
either create or interact with data. We will make use of similar features to 
create some 2D data to attach to our plane. 
Specifically, we will use the 
<code>Python Calculator</code>, which will enable us to provide, in Python, the
analytic expression of a 2D function to be considered as the input to our 
topological data analysis pipeline.<br><br>

In particular, we will create a Gaussian function, given by the 
expression:<br><br> 
<myMath>$f(p) = e^{-{{||p - \mu||^2_2}\over{2\sigma^2}}}$</myMath><br><br>
where 
<myMath>$p$</myMath> is the current point where to evaluate the function, and 
where <myMath>$\mu$</myMath> and <myMath>$\sigma$</myMath> are the mean and 
standard deviation of the Gaussian.<br><br>

In ParaView, each filter can have multiple inputs. In Python, the first input 
of our <code>Python Calculator</code> filter can be accessed by the variable 
<code>inputs[0]</code>. The actual points attached to this input can be 
accessed by its <code>Points</code> attribute: <code>inputs[0].Points[]</code>. 
Therefore, in your <code>Python calculator</code>, accessing the <code>x</code> 
and <code>y</code> components of your current point <code>p</code> can be done 
by considering the following expressions respectively: 
<code>inputs[0].Points[:,0]</code> (for x) and 
<code>inputs[0].Points[:,1]</code> (for y).<br><br>

Use these expressions of the coordinates of the input points to evaluate in 
your <code>Python Calculator</code> the analytic expression of 
<myMath>$f(p)$</myMath> given above, to generate a 2D Gaussian as shown in the 
example below (do not forget to name your function with a specific string for 
the <code>Array Name</code> parameter, typically <code>gaussian0</code>).<br>

<div class=caption>
  <a href="img/persistenceDummies_firstGaussian.png" target="new">
    <img width="100%" src="img/persistenceDummies_firstGaussian.png">
  </a>
</div>

Now, re-iterate this process successively twice to 
create two other Gaussians, centered in other parts of the plane, with distinct 
standard deviations. Finally, use the <code>Python Calculator</code> to blend 
linearly the three Gaussians you generated into only one function, called 
<code>multiGaussian</code>, as illustrated below:<br>

<div class=caption>
  <a href="img/persistenceDummies_multiGaussian.png" target="new">
    <img width="100%" src="img/persistenceDummies_multiGaussian.png">
  </a>
</div>



<h4>Exercise 2</h4>
We will now inspect this toy data set as a 3D terrain. First, create a new 
render view, by clicking on the <code>Split Horizontal</code> button, located 
in the top right corner of the current render view (next to the string 
<code>RenderView1</code>). Next, in the newly created view, click on the 
<code>Render View</code> button.<br><br>

To generate a 3D terrain, we will first triangulate the plane, which is 
currently represented as a 2D regular grid. For this, select the last 
<code>Python Calculator</code> object in your pipeline and call the 
<code>Tetrahedralize</code> filter on it. Next, we will modify the x, y and z 
coordinates of the vertices of this mesh to create a terrain.<br><br>

To do this, we will use the <code>Programmable Filter</code> and enter some 
Python instructions to assign the previously define multi-gaussian function, 
named <code>multiGaussian</code>, as a z coordinate. <code>Programmable 
Filters</code> generate only one output, which is by default a copy of the input 
geometry. Thus, to access the output of your <code>Programmable Filter</code>, 
you need to use the Python expression <code>output</code>. Then, the z 
coordinate of the output can be accessed, similarly as to the previous 
exercise, by considering 
the Python expression <code>output.Points[:, 2]</code>.
The scalar data that we generated in the 
previous exercise (<code>multiGaussian</code>) can be 
accessed by considering the field <code>multiGaussian</code> on the point data 
of the first input. This is achieved by considering the expression 
<code>inputs[0].PointData["multiGaussian"]</code>. <br><br>

Now enter the 
correct Python instruction in the <code>Script</code> text-box of your 
<code>Programmable Filter</code> to assign the <code>multiGaussian</code> value 
to the z coordinate of each point of the data and click on the 
<code>Apply</code> button. If you got it right, you should be visualizing 
something like this:<br>
<div class=caption>
  <a href="img/persistenceDummies_terrain.png" target="new">
    <img width="100%" src="img/persistenceDummies_terrain.png">
  </a>
</div>

By default, the scalar fields attached to the input of our 
<code>Programmable Filter</code> have not been copied over to the output of the 
filter. We will now copy the field <code>multiGaussian</code>, in order to 
apply further processing on it. To add some data array to your output object, 
you need to use the function <code>append()</code> on your 
<code>output.PointData</code> object. This function takes as a first argument 
the actual data array (in our case 
<code>inputs[0].PointData["multiGaussian"]</code>) and as a second argument a 
string, used to name the created data array (in our case, let us name it 
<code>multiGaussian</code> too).<br><br>

Add a second instruction in the <code>Script</code> text-box of your 
<code>Programmable Filter</code> to copy the field 
<code>inputs[0].PointData["multiGaussian"]</code> over to your output and click 
on the <code>Apply</code> button. If you got it right, you should be 
visualizing something like this:<br>
<div class=caption>
  <a href="img/persistenceDummies_terrainScalar.png" target="new">
    <img width="100%" src="img/persistenceDummies_terrainScalar.png">
  </a>
</div>
Now, select the left render view (with the 2D version of your data), by 
clicking in it. Next, in the pipeline browser, trigger the display of the 
output of your <code>Programmable Filter</code>, by enabling the eye icon on 
its left. Adjust its display properties (<code>Coloring</code>, 
<code>Specular</code>, <code>Ambient</code> and <code>Diffuse</code>)
to obtain a 
visualization comparable to the above screenshot.<br><br>

</p>
<p>
<h4><a name="betti_paraview">4.</a> Sub-level set homology</h4>

<h4>Exercise 3</h4>
We will now visualize and inspect the evolution of the topology (of the
<i>Betti numbers</i> <myMath>$\beta_0$</myMath> and <myMath>$\beta_1$</myMath>)
of the sub-level sets <myMath> $f^{-1}_{-\infty}(i)$ </myMath>as 
<myMath>$i$</myMath> continuously sweeps the data. For further readings on 
persistent homology, see the following 
	<a 
href="http://www.ee.oulu.fi/research/imag/courses/Vaccarino/Edels_Book.pdf"
target="new">
reference text book</a> (page 190 of the PDF file) or the following 
<a 
href="http://www-pequan.lip6.fr/~tierny/stuff/teaching/
tierny_topologicalDataAnalysis.pdf" target="new"> course notes
</a>.
<br><br>

In the pipeline browser, select your <code>Programmable Filter</code> and call 
the <code>Threshold</code> filter, to only select the points below on certain 
isovalue of <code>multiGaussian</code>. Trigger the display of the 
<code>Threshold</code> in both views, to obtain the following visualization:
<br>
<div class=caption>
  <a href="img/persistenceDummies_subLevelSet.png" target="new">
    <img width="100%" src="img/persistenceDummies_subLevelSet.png">
  </a>
</div>

We will additionally compute and display the level set at the same isovalue: 
<myMath>$f^{-1}(i)$</myMath>. 
For this, in the pipeline browser, select your <code>Programmable Filter</code> 
and call the <code>Contour</code> filter and extract a level set at the same 
isovalue. Next call the <code>Tube</code> filter on the output of the 
<code>Contour</code> filter, to represent the computed level set with a 
collection of cylinder primitives, in both views, as illustrated below:
<br>
<div class=caption>
  <a href="img/persistenceDummies_levelSet.png" target="new">
    <img width="100%" src="img/persistenceDummies_levelSet.png">
  </a>
</div>

<h4>Exercise 4</h4>
We will now animate the sweeping of the data and visualize the corresponding 
animation. 
<br><br>
In the <code>View</code> menu, check the <code>Animation View</code> check-box. 
The <code>Animation View</code> panel appears at the bottom of the screen. We 
will first setup the length of the animation by setting the 
<code>EndTime</code> parameter to <code>10</code> (seconds). Next, we will set 
the frame rate to an admissible value (25 fps) and therefore set the parameter 
<code>No. Frames</code> to <code>250</code>.<br><br>
We will now specify which parameters of our visualization should vary during 
the animation. In particular, we want the isovalue (of the sub- and level sets) 
to continuously increase with time. For this, at the bottom left of the 
<code>Animation View</code>, next to the <code>+</code> icon, select your 
<code>Threshold</code> filter in the left scrolling menu and then, within 
the right scrolling menu, select  its 
parameter 
capturing the isovalue (<code>Threshold Range (1)</code>)  and click on the 
<code>+</code> button. Next, also add the <code>Contour</code> filter to the 
animation by selecting it 
in the bottom left scrolling menu and 
by clicking on the 
<code>+</code> button (the default selected parameter <code>Isosurfaces</code> 
is precisely the parameter we want to animate). <br><br>

Your animation is now ready to play!<br> Go ahead and click on the 
<code>Play</code> button at the top of the screen. If you got it right, you 
should be visualizing 
something like this:<br>
<div class=caption>
  <a href="img/persistenceDummies_animation.png" target="new">
    <img width="100%" src="img/persistenceDummies_animation.png">
  </a>
</div>

For what isovalues <myMath>$i$</myMath>:<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; does 
<myMath>$\beta_0(f^{-1}_{-\infty}(i))$</myMath> increase?<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; does 
<myMath>$\beta_0(f^{-1}_{-\infty}(i))$</myMath> decrease?<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; does 
<myMath>$\beta_1(f^{-1}_{-\infty}(i))$</myMath> increase?<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; does 
<myMath>$\beta_1(f^{-1}_{-\infty}(i))$</myMath> decrease?<br>

<br>

<h4>Exercise 5</h4>
We will now identify the exact locations in the data where the Betti numbers of 
<myMath>$f^{-1}_{-\infty}(i)$</myMath> change. <br><br>
Select the view with the 3D terrain by clicking in it. In the pipeline browser, 
select the output of your <code>Programmable Filter</code> and call the filter 
<code>TTK ScalarFieldCriticalPoints</code> on it.<br>
The output of this filter is a point cloud that may be difficult to visualize 
by default. We will enhance this visualization by displaying a visual glyph for 
each point, in particular, a sphere. Call the filter <code>TTK 
SphereFromPoint</code> filter on the output of the <code>TTK 
ScalarFieldCriticalPoints</code> filter and adjust the <code>Radius</code> 
parameter. Next, change the coloring of these spheres, in order to use the 
array <code>CriticalIndex</code>. Finally, select the 2D view on the left by 
clicking in it and trigger the display of these spheres, with the same display 
properties.
If you got it right, you should be 
visualizing something like this:
<br>
<div class=caption>
  <a href="img/persistenceDummies_criticalPoints.png" target="new">
    <img width="100%" src="img/persistenceDummies_criticalPoints.png">
  </a>
</div>

How does the field <code>CriticalIndex</code> (color-coded on the spheres) 
relate to:<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; the increase of
<myMath>$\beta_0(f^{-1}_{-\infty}(i))$</myMath>?<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; the decrease of 
<myMath>$\beta_0(f^{-1}_{-\infty}(i))$</myMath>?<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; the increase of
<myMath>$\beta_1(f^{-1}_{-\infty}(i))$</myMath>?<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; the decrease of
<myMath>$\beta_1(f^{-1}_{-\infty}(i))$</myMath>?<br>


</p>
<p>
<h4><a name="betti_paraview">5.</a> Persistent homology</h4>

<h4>Exercise 6</h4>
We will now inspect this data from the view point of persistent 
homology.<br><br>

Create a third view on the right by clicking on the <code>Split 
Horizontal</code> button, located at the top right corner of the right render 
view (next to the string <code>RenderView2</code>) and then click on the 
<code>Render View</code> button.<br><br>

In the pipeline browser, select the output of your <code>Programmable 
Filter</code> and call the filter <code>TTK PersistenceDiagram</code> on it. A 
persistence diagram should display in the newly created view.<br><br>

The visualization of the persistence diagram can be improved in several ways. 
First, in the display properties of the <code>TTK PersistenceDiagram</code> 
filter, enable the display of the axes by checking the <code>Axes Grid</code> 
check-box (you can tune its parameters, such as the name of the axes by 
clicking on the <code>Edit</code> button next to it).<br><br>

Next, we will improve the visualization of the diagram itself. By default, the 
diagram embeds a virtual edge representing the diagonal. This virtual edge can 
be filtered out to be removed from the visualization or to be visualized with a 
distinct color. This virtual edge can be isolated from the others as it is the 
only edge with a negative value for the field <code>PairIdentifier</code>. Use 
the <code>Threshold</code> filter on the output of the <code>TTK 
PersistenceDiagram</code> filter to isolate this edge. Next, convert your 
selected edge to a polygonal surface representation by calling the 
<code>Extract Surface</code> filter on it. Finally, represent this edge with a 
cylinder primitive by calling the <code>Tube</code> filter (adjust the 
<code>Radius</code> and coloring properties).<br><br>

Next, we will also display the actual persistent pairs with cylinders. For 
this, in the pipeline browser, select the output of the <code>TTK 
PersistenceDiagram</code> filter and apply the <code>Threshold</code> filter on 
it to only display these pairs with non-negative values for the field 
<code>PairIdentifier</code>. Next, convert this selection into a polygonal 
surface representation by calling the 
<code>Extract Surface</code> filter and represent these edges with cylinder 
primitives by calling the <code>Tube</code> filter (adjust the 
<code>Radius</code> and coloring properties).<br><br>

Finally, we will represent each extremity of a persistence pair by a visual 
glyph, in particular, a sphere. For this, in the pipeline browser, select the 
output of the <code>Threshold</code> filter which selected the pairs with 
non-negative identifiers in the diagram and apply the <code>TTK 
SphereFromPoint</code> filter on it. Adjust the radius and set the coloring to 
use the field <code>NodeType</code>. If you got it right, you should be 
visualizing something like this:
<br>
<div class=caption>
  <a href="img/persistenceDummies_persistenceDiagram.png" target="new">
    <img width="100%" src="img/persistenceDummies_persistenceDiagram.png">
  </a>
</div>

Given the persistence diagram on the right, identify in the original data 
(on the left) the least persistent critical point pairs responsible for changes 
in <myMath>$\beta_0(f^{-1}_{-\infty}(i))$</myMath> and 
<myMath>$\beta_1(f^{-1}_{-\infty}(i))$</myMath> respectively.
<br><br>

<h4>Exercise 7</h4>
We will now illustrate stability results on the persistence diagram and 
experiment with persistence-sensitive function simplification.
<br><br>

Split the render view containing the persistent diagram using the 
<code>Split Vertical</code> bottom (top right corner, second button after the 
string <code>RenderView3</code> and click on the <code>Render View</code> 
button. In this view, display the diagonal of the persistence diagram as well 
as the persistence pairs more persistent than the two pairs identified in the 
previous question (use the <code>Threshold</code> filter on the 
<code>Persistence</code> array to isolate those, as the pairs above a given 
persistence threshold and below an arbitrarily high threshold, for instance 
<code>9999</code>). Enhance the visualization, as suggested in the previous 
question.  If you got it right, you should be 
visualizing something like this:

<br>
<div class=caption>
  <a href="img/persistenceDummies_secondPersistenceDiagram.png" target="new">
    <img width="100%" src="img/persistenceDummies_secondPersistenceDiagram.png">
  </a>
</div>

We will now reconstruct a function <myMath>$g : \mathcal{M} 
\rightarrow \mathbb{R}$</myMath> that admits this simplified persistence 
diagram <myMath>$\mathcal{D}(g) \subset \mathcal{D}(f)$</myMath>. <br><br>

Before reconstructing the function  <myMath>$g$</myMath>, we will first make a 
copy of the original function, that we will simplify. 
For this, in the pipeline browser, click on 
your <code>Programmable Filter</code> and add a Python instruction in the 
<code>Script</code> text-box to add a new field named 
<code>simplifiedGaussian</code> which is a copy of the field 
<code>multiGaussian</code> (see exercise 2).
Next, apply the filter <code>Clean to Grid</code> on the output of your 
<code>Programmable Filter</code>, which will effectively perform the data copy.
<br><br>

Next, select the render view with the 3D terrain by clicking in it and 
split it vertically, 
using the 
<code>Split Vertical</code> bottom (top right corner, second button after the 
string <code>RenderView2</code> and click on the <code>Render View</code> 
button. Now, in the pipeline browser, select the output of the <code>Clean 
to Grid</code> filter
and call the filter <code>TTK TopologicalSimplification</code> 
on it. A dialog window opens to specify the two inputs of this filter. The 
first 
input, named <code>Domain</code> (see the left ratio buttons), should already 
be set properly to your <code>Clean 
to Grid</code> filter. The second input, 
named <code>Constraints</code> (see the left ratio buttons), refers to the 
persistent pairs which we want to keep in the reconstructed function  
<myMath>$g$</myMath>. These correspond to the apparent edges in the simplified 
persistence diagram <myMath>$\mathcal{D}(g) \subset \mathcal{D}(f)$</myMath>. 
Therefore, for this input, you should select in your pipeline the 
<code>Threshold</code> filter you used to select the most persistent pairs of 
the first diagram <myMath>$\mathcal{D}(f)$</myMath>. Once this is done, click 
on <code>Ok</code>. Now, before clicking on the green <code>Apply</code> 
button, in the properties panel, check the <code>Numerical Perturbation</code> 
check-box, make sure that you are applying the simplification to the scalar 
field <code>simplifiedGaussian</code> and
click on <code>Apply</code> . Link this terrain view with the 
one 
above by right clicking in the bottom view, selecting the entry <code>Link 
Camera...</code> and then clicking on the top view. If you got it right, you 
should be visualizing something like this:

<br>
<div class=caption>
  <a href="img/persistenceDummies_reconstruction.png" target="new">
    <img width="100%" src="img/persistenceDummies_reconstruction.png">
  </a>
</div>

Similarly to the exercise 2, we will now modify the geometry of the terrain, 
such that the z coordinate of each point becomes equal to the simplified 
function <myMath>$g$</myMath>, named <code>simplifiedGaussian</code>. For 
this, select the filter <code>TTK 
TopologicalSimplification</code> in the pipeline browser and call a 
<code>Programmable Filter</code> on it and apply the same processing as in 
the exercise 2 (but on our new field <code>simplifiedGaussian</code>). Do not 
forget to copy the fields <code>simplifiedGaussian</code> and 
<code>multiGaussian</code>.
Also, the filter <code>TTK 
TopologicalSimplification</code> generates an <i>offset</i> field (or 
<i>tiebreak</i> field) named <code>OutputOffsetScalarField</code>. Make sure to 
also copy this field, as it is necessary to further process the simplified data 
properly.
<br><br>

Now split the left view vertically, using the 
<code>Split Vertical</code> bottom (top right corner, second button after the 
string <code>RenderView1</code> and click on the <code>Render View</code> 
button. Click now on the <code>3D</code> icon (top left corner of the view) to 
switch it to <code>2D</code> and trigger the display of the output of the 
second <code>Programmable Filter</code> in it. Adjust its display properties 
(<code>Coloring</code>, 
<code>Specular</code>, <code>Ambient</code> and <code>Diffuse</code>)
to obtain a visualization that is consistent with the above view. Link this 2D 
bottom view with the above one (right click, <code>Link 
Camera...</code>).<br><br>

Next, we will extract the critical points of <myMath>$g$</myMath> and 
visualize them in both bottom views (2D plane and 3D terrain). In the pipeline 
browser, select the output of the 
second <code>Programmable Filter</code> and call the filter <code>TTK 
ScalarFieldCriticalPoints</code>. Before clicking on the <code>Apply</code> 
button, check the check-box <code>Use Input Offset Field</code> and make sure 
you are applying this filter to the scalar field 
<code>simplifiedGaussian</code>. Finally, enhance this visualization by 
displaying a sphere for each critical point, colored by its critical index, with 
<code>TTK SphereFromPoint</code>, and display these spheres in both bottom views 
(2D plane and 3D terrain).<br><br>

Finally, we will extract and animate the sub-level sets 
<myMath>$g^{-1}_{-\infty}(i)$</myMath> and level sets 
<myMath>$g^{-1}(i)$</myMath> of <myMath>$g$</myMath>, to visually compare them 
with these of <myMath>$f$</myMath>. In the pipeline browser, select the output 
of the second <code>Programmable Filter</code> and, similarly to exercise 3, 
call the <code>Threshold</code> filter on it to display 
<myMath>$g^{-1}_{-\infty}(i)$</myMath> in both bottom views (2D plane and 3D 
terrain) and adjust display properties in 2D. Next, in the pipeline browser, 
select the output 
of the second <code>Programmable Filter</code> again and call the 
<code>Contour</code> filter on it to extract <myMath>$g^{-1}(i)$</myMath>, 
followed by the <code>Tube</code> filter (to display it with cylinder 
primitives) and trigger its display in both bottom views (2D plane and 3D 
terrain). We will now complete the animation by animating the isovalue 
<myMath>$i$</myMath> for both <myMath>$g^{-1}_{-\infty}(i)$</myMath> and 
<myMath>$g^{-1}(i)$</myMath>. 
In the <code>View</code> 
menu, check the <code>Animation View</code> check-box and similarly to exercise 
4, add <myMath>$g^{-1}_{-\infty}(i)$</myMath> and 
<myMath>$g^{-1}(i)$</myMath> to the animation.<br><br>

At this point, your animation is ready to play!<br>
Go ahead and click on the <code>Play</code> button at the top of the screen.
If you got it right so far, you 
should be visualizing something like this:

<br>
<div class=caption>
  <a href="img/persistenceDummies_simplified.png" target="new">
    <img width="100%" src="img/persistenceDummies_simplified.png">
  </a>
</div>

Now, in the pipeline browser, select the <code>Threshold</code> filter with 
which you controlled the persistence threshold (beginning of exercise 7) and 
increase that threshold until <myMath>$g$</myMath> admits only one maximum. 
Play the animation and inspect the shape of 
<myMath>$g^{-1}_{-\infty}(i)$</myMath> in the vicinity of the canceled maxima.
You should be visualizing something like this:
<br>
<div class=caption>
  <a href="img/persistenceDummies_artifact.png" target="new">
    <img width="100%" src="img/persistenceDummies_artifact.png">
  </a>
</div>
How can you explain this visual artifact?<br><br>
In the <code>TTK TopologicalSimplification</code> filter, un-check the 
check-box <code>Numerical Perturbation</code> and click on <code>Apply</code>. 
How can you explain the disappearance of the artifact?
<br><br>

<h4>Exercise 8</h4>
We will now inspect the stability of the persistence diagram.<br><br>

Split vertically the top right view (containing the original persistence 
diagram <myMath>$\mathcal{D}(f)$</myMath>) with the <code>Split Vertical</code> 
button and click on <code>SpreadSheet View</code>. In the scrolling menu named 
<code>Showing</code>, select from your pipeline the <code>TTK 
PersistenceDiagram</code> and select in the <code>Attribute</code> scrolling 
menu the entry <code>Cell Data</code>. This will display in a spreadsheet the 
information associated with each pair of the persistence diagram, including its
persistence (last column), as shown below.

<br>
<div class=caption>
  <a href="img/persistenceDummies_spreadSheet.png" target="new">
    <img width="100%" src="img/persistenceDummies_spreadSheet.png">
  </a>
</div>

Sort the spreadsheet by persistence by clicking on the header of the 
corresponding column.<br> Now, write down the persistence of the most 
persistence pair which is absent from the bottom diagram below 
(<myMath>$\mathcal{D}(g)$</myMath>).<br><br>

We will now evaluate <myMath>$||f-g||_\infty$</myMath>.<br>
First, click in the bottom left view to activate it. Next, in the pipeline 
browser, select the output of the second <code>Programmable Filter</code> and 
call a <code>Python Calculator</code> on it. Now, enter the Python expression 
to evaluate <myMath>$|f(p)-g(p)|$</myMath> for each point 
<myMath>$p$</myMath> and call the output function 
<code>absoluteDifference</code>. 
If you got it right, you 
should be visualizing something like this:
<br>
<div class=caption>
  <a href="img/persistenceDummies_difference.png" target="new">
    <img width="100%" src="img/persistenceDummies_difference.png">
  </a>
</div>

Now split the bottom left view vertically with the <code>Split Vertical</code> 
button and click on <code>SpreadSheet View</code>. 
In the scrolling menu named 
<code>Showing</code>, select from your pipeline the last <code>Python 
Calculator</code>.
This will display in a spreadsheet the 
information associated with each vertex of the domain, including its 
<code>absoluteDifference</code> value, as shown below.

<br>
<div class=caption>
  <a href="img/persistenceDummies_differenceSpreadSheet.png" target="new">
    <img width="100%" src="img/persistenceDummies_differenceSpreadSheet.png">
  </a>
</div>

Sort the spreadsheet by <code>absoluteDifference</code>
by clicking on the header of the 
corresponding column.
Click on the spreadsheet entry that maximizes <code>absoluteDifference</code>. 
You should see the corresponding point highlighted in the above view. <br><br>

What does this point correspond to?<br>
How does its absolute difference value relate to the original persistence 
diagram?


</p>
<p>
<h4><a name="betti_paraview">6.</a> Topological data segmentation</h4>

In our example, somehow, persistent homology helped us answer the following 
question:<br><br> <i>What is the second highest mountain of my 
terrain?</i><br><br> 
We saw that the answer is not necessarily the second 
highest <i>summit</i> (second highest local maximum) but the second most 
persistent summit.<br><br>

We will now combine persistent homology and split trees, in order to extract 
precisely the geometry of the second highest mountain of our terrain.<br><br>

<h4>Exercise 9</h4>
Click in the top center view to activate it. Next, in the pipeline browser, 
select the output of the first <code>Programmable Filter</code> and call the 
filter <code>TTK Merge and Contour Tree (FTM)</code> on it (select 
<code>Split Tree</code> as <code>Tree Type</code>). This filter generates 
multiple outputs. Select the output <code>Segmentation</code> and change its 
<code>Opacity</code> to <code>0.3</code>. Now, you should see an embedding of 
the split tree of your data. In the following, we will slightly enhance this 
embedding.<br><br>

Modify the parameter <code>Arc Sampling </code> of your <code>TTK Merge and 
Contour Tree (FTM)</code> filter to a reasonable value (typically 
<code>10</code>). Next, select its output <code>Skeleton Arcs</code> and call 
the filter <code>TTK GeometrySmoother</code> and check the box <code>Use Input 
Mask Field</code>. At this point, you may want to edit the number of smoothing 
iterations (typically to <code>30</code>), to obtain a smoother embedding of 
the split tree. Next, we will display the arcs of the tree with cylinder 
primitives. For this, call the <code>Extract Surface</code> filter (to convert 
the arcs to a polygonal representation) and then the <code>Tube</code> filter.
If you got it right, you 
should be visualizing something like this:
<br>
<div class=caption>
  <a href="img/persistenceDummies_reeb.png" target="new">
    <img width="100%" src="img/persistenceDummies_reeb.png">
  </a>
</div>

Now, go ahead and do the same thing for the simplified function in the bottom 
view. When calling the filter <code>TTK Merge and 
Contour Tree (FTM)</code>, remember to use the <code>simplifiedGaussian</code> 
field and to check the box <code>Use Input Offset Scalar Field</code>. At this 
point, you may want to reduce the persistence threshold (beginning of exercise 
7), to obtain a visualization like this one:
<br>
<div class=caption>
  <a href="img/persistenceDummies_reebSimplified.png" target="new">
    <img width="100%" src="img/persistenceDummies_reebSimplified.png">
  </a>
</div>

<h4>Exercise 10</h4>

Thanks to the split tree, the geometry of each mountain can be extracted by 
collecting the set of vertices of the domain which map to arcs in the split
tree which are connected to local maxima. We will now extract these 
regions.<br><br>

Click on the top center view to activate it. Now, in the pipeline browser, 
select the <code>Segmentation</code> output of the first <code>TTK Merge and 
Contour Tree (FTM)</code> filter. Now, apply the <code>Threshold</code> filter, 
in order to only show these vertices that have a <code>RegionType</code> value 
of <code>1</code>. This will extract all vertices mapping to arcs connected to 
local maxima. Change the display properties of these vertices to color them by 
the field <code>SegmentationId</code> (you can edit the color map by clicking on 
the <code>Edit</code> button). Trigger their visualization in the top left 
view, with the same coloring scheme.
<br>
You 
should now be visualizing something like this:
<br>
<div class=caption>
  <a href="img/persistenceDummies_reebSegmentation.png" target="new">
    <img width="100%" src="img/persistenceDummies_reebSegmentation.png">
  </a>
</div>
Now, go ahead and do the same thing for the simplified data in the bottom views.

<br>
<div class=caption>
  <a href="img/persistenceDummies_reebSegmentationSimplified.png" target="new">
    <img width="100%" 
src="img/persistenceDummies_reebSegmentationSimplified.png">
  </a>
</div>
If you managed to get a visualization similar to the above screenshot, 
congratulations!<br>
You've just extracted the geometry of the two highest mountains of your terrain 
(bottom views). You can now play with the persistence threshold (beginning 
of exercise 7) to explore the hierarchy of your data segmentation.
<br>

</p>
<p>
<h4><a name="betti_paraview">6.</a> Topological data segmentation in Python</h4>

We will now implement a similar analysis pipeline in Python, thanks to ParaView 
Python export capabilities.
<br><br>

<h4>Exercise 11</h4>

First, in your pipeline browser, select the output of your first 
<code>Programmable Filter</code> (corresponding to the first, non-simplified 3D 
terrain). Next, save this data to disk with the menu <code>File</code>, 
<code>Save Data...</code> (select the <code>vtu</code> file extension). You can 
now close ParaView.<br><br>

Re-open now ParaView and load the file you have just saved. Split the current 
view horizontally and compute and display the persistence diagram of your data 
in this new view.<br><br>
Now threshold your diagram to remove the diagonal and threshold again to remove 
low persistence pairs (see exercise 7).

Next, activate the left view by clicking in it and select your 3D terrain in 
the pipeline browser and call the <code>TTK TopologicalSimplification</code> 
filter on it, using as constraints the persistent pairs you selected 
previously from the persistence diagram (see exercise 7).<br><br>

Next, compute the split tree of the simplified data (see exercise 9, do not 
forget to check the box <code>Use Input Offset Scalar Field</code>). Finally, 
threshold the <code>Segmentation</code> output of the split tree, to only 
visualize vertices with a <code>RegionType</code> value of 1.<br><br>

At this point, you should be visualizing something like this:
<br>
<div class=caption>
  <a href="img/persistenceDummies_basicPipeline.png" target="new">
    <img width="100%" 
src="img/persistenceDummies_basicPipeline.png">
  </a>
</div>

We will now convert this simple analysis pipeline into a Python script. For 
this, enter the menu <code>File</code>, <code>Save state...</code> and choose 
the Python state file type and save your file with the name 
<code>pipeline.py</code>.<br><br>

We will now turn the generated Python script into an independently executable 
program. <br>This script relies on the Python layer of TTK and 
ParaView. It should be interpreted with <code>pvpython</code>, which wraps 
around the 
traditional Python interpretor, in order to set the required environment 
variables properly. To automatically run the script with the right interpretor, 
we will add the following line at the very top of the generated script:
<br><br>
<code>
#!/usr/bin/env pvpython
</code><br><br>
Next, we will make the script executable by setting its execution bit, by 
entering the following command (omit the <code>$</code> character):<br><br>
<code>
$ chmod +x pipeline.py
</code>
<br><br>
Your Python program can now be run by simply entering the following command  
(omit the <code>$</code> character):<br><br>
<code>
$ ./pipeline.py
</code>
<br><br>

By default, this program loads the input terrain, simplify the data, segment 
the mountains with the split tree and simply exits. We will now modify this 
script to store to disk the segmentation of the highest mountains.<br><br>

For this, open the script with a text editor and identify the part of the 
script which thresholds the segmentation according to the 
<code>RegionType</code> field.
After this paragraph, add a Python instruction to save the 
<code>Threshold</code> object to disk, with the function 
<code>SaveData()</code>, which takes as a first argument a filename 
(for example 
<code>segmentation.vtu</code>) 
and as 
a second argument a pipeline object (here the instance of 
<code>Threshold</code> object). Save your file and execute your script. It 
should have written to disk a file named <code>segmentation.vtu</code>. Open it 
in ParaView. You should be visualizing something like this:

<br>
<div class=caption>
  <a href="img/persistenceDummies_scriptOutput.png" target="new">
    <img width="100%" 
src="img/persistenceDummies_scriptOutput.png">
  </a>
</div>

Note that other file formats are supported. Modify your script to save the 
segmentation into the file <code>segmentation.csv</code> instead of 
<code>segmentation.vtu</code> and run your script again. It should have 
produced a plain ASCII file storing the segmentation, which can be opened and 
parsed with any other software.<br><br>


<h4>Exercise 12</h4>
Note that, in our Python script,  the instructions located after the saving of 
the segmentation deal with rendering parameters. Thus, these can be removed in 
our context since we are using the script in batch mode. Other instructions 
related to render views can also be removed for the same reason.<br>
Remove all the Python instructions that are not 
strictly necessary for the computation of the output segmentation. At this 
point, your script should have less than 25 instructions and should therefore 
be much easier to read.

<br><br>
<h4>Exercise 13</h4>
Now edit your Python script in order to read the persistence threshold with 
which the data should be simplified from the command line, as an argument of 
your Python script.
<br>

</p>
<p>
<h4><a name="betti_paraview">7.</a> Topological segmentation of medical data</h4>

We will now apply our topological data analysis pipeline to some real-life 
medical data.<br>

For this open with ParaView the following data set:
<br><br>
<code>~/ttk/ttk-data-0.9.3/ctBones.vti</code>
<br><br>

Now, deploy the topological data analysis pipeline we designed in this tutorial, 
in order to segment the 5 <i>highest mountains</i> of this CT scan:<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; 
Computation of the persistence diagram of the data;<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; 
Selection of the 5 most persistent pairs;<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; 
Topological simplification of the data according to the persistence selection;<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; 
Computation of the split tree of the simplified data;<br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp; 
Segmentation of the regions mapping to branches of the split tree connected to maxima;<br><br>

If you got it right, your pipeline should precisely isolate the bones of the foot and you 
should be visualizing something like this:
<br>
<div class=caption>
  <a href="img/gallery/ctBones.jpg" target="new">
    <img width="100%" 
src="img/gallery/ctBones.jpg">
  </a>
</div>
If so, congratulations, you've just managed to segment medical data thanks to topological data analysis!

</p>



</p>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <p class="copyright text-muted">
                    Contact: <a href="mailto:topology.tool.kit@gmail.com">
                    topology.tool.kit@gmail.com</a><br>
                    Updated on November 20th, 2017.</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="vendor/jquery/jquery.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="vendor/bootstrap/js/bootstrap.min.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Theme JavaScript -->
    <script src="js/clean-blog.min.js"></script>

</body>

</html>
